단위 테스트
===

### TDD 법칙 세 가지

TDD 법칙 세 가지
- 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위와 같이 코드를 작성하면 사실상 전부 테스트하는 테스트 케이스가 나온다.?

하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

<br>

### 깨끗한 테스트 코드 유지하기

지저분한 테스트를 하는 것은 테스트를 안 하는 것 보다 못하다.

테스트 코드가 지저분하면? <br>
=> 실제 코드가 진화하면 테스트 코드도 진화해야 하는데, 테스트 코드가 지저분할수록 변경이 어려워진다. <br>
=> 새 버전을 출시할 때마다 테스트 케이스를 유지,보수하는 비용이 늘어난다. <br>
=> 결국 테스트 슈트를 폐기하게 된다. <br>
=> 테스트 슈트가 없으면? 수정한 코드가 제대로 도는지 확인할 방법이 없다. <br>
=> 결함률이 높아짐. <br>
=> 변경할수록 결함률이 높아지면, 변경을 주저하게 됨. <br>
=> 점점 코드가 망가지기 시작. <br>

위와 같은 상황이 나오지 않으려면? <br>
**테스트 코드는 실제 코드 못지않게 중요하게 짜야 한다.**

실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. <br>
테스트는 유연성, 유지보수성, 재사용성을 제공한다. <br>
테스트 케이스가 있으면 변경이 쉬워지기 때문이다. <br>

테스트 코드가 지저분할수록 실제 코드도 지저분해진다. <br>
결국 테스트 코드를 잃어버리고 실제 코드도 망가진다. <br>

<br>

### 깨끗한 테스트 코드

깨끗한 테스트 코드를 만들려면 가독성이 필요하다. <br>
테스트 코드에 가독성을 높이려면? <br>
명료성, 단순성, 풍부한 표현력이 필요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다. <br>

BUILD-OPERATE-CHECK 패턴에 적합한 테스트 구조 (3가지 부분으로 나눔.)
1. 테스트 자료를 만드는 부분
2. 테스트 자료를 조작하는 부분
3. 조작한 결과가 올바른지 확인하는 부분

잡다하고 세세한 코드는 거의 다 없애고, 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용해야 한다. <br>

- 도메인에 특화된 테스트 언어 <br>
  ..
- 이중 표준 <br>
  ..

<br>

### 테스트 당 assert 하나

assert 문이 단 하나인 함수의 장점 : 결론이 하나라서 코드를 이해하기 쉽고 빠르다.

이것은 필수는 아니지만 assert 문 개수를 줄이면 좋다.

어쩌면 assert 문 하나 대신 "테스트 함수마다 한 개념만 테스트하라"는 규칙이 더 나을 수 있다.

결론 : "개념 당 assert 문 수를 최소로 줄여라" AND "테스트 함수 하나는 개념 하나만 테스트하라"

<br>

### F.I.R.S.T.

깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.

- **F**ast <br>
  테스트는 빨라야 한다. <br>
  =>빠르지 못하면 테스트를 자주 돌릴 엄두를 못 낸다. <br>
  => 자주 돌리지 않으면 초반에 문제를 고치지 못하고, 정리도 못한다. <br>
  => 코드 품질이 망가지기 시작한다.

- **I**ndependent <br>
  각 테스트는 서로 의존하면 안 된다. <br>
  => 테스트가 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워짐. <br>
  => 후반 테스트가 찾아내야 할 결함이 숨겨짐.

- **R**epeatable <br>
  테스트는 어떤 환경에서도 반복 가능해야 한다. <br>
  =>테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.

- **S**elf-validating <br>
  테스트는 부울*bool* 값으로 결과를 내야 한다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다. <br>
  => 테스트 스스로가 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.

- **T**imely <br>
  테스트는 적시에 작성해야 한다. <br>
  단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

<br>

### 결론

- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화한다.
- 테스트 코드는 지속적으로 깨끗하게 관리하자.
- 표현력을 높이고 간결하게 정리하자.
- 테스트 API를 구현해 도메인 특화 언어를 만들자.

그럼 테스트 코드를 짜기가 쉬워진다.

<br>